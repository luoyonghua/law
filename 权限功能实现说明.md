# 权限功能实现说明

## 概述
实现了基于角色的权限控制系统，支持三种用户角色：超级管理员、管理员和普通用户，每个角色拥有不同的功能权限。

## 角色定义

### 1. 超级管理员（R_SUPER）
**权限**：拥有所有功能权限
- ✅ 上传文书
- ✅ 批量提取
- ✅ 文书比对
- ✅ 文书审查
- ✅ 结构化提取
- ✅ 下载文档
- ✅ 查看详情
- ✅ 系统管理（用户、角色、菜单）

**登录账号**：
- 用户名：`Super`
- 密码：`123456`

### 2. 管理员（R_ADMIN）
**权限**：除上传文书外的所有功能
- ❌ 上传文书
- ✅ 批量提取
- ✅ 文书比对
- ✅ 文书审查
- ✅ 结构化提取
- ✅ 下载文档
- ✅ 查看详情
- ✅ 部分系统管理（用户管理）

**登录账号**：
- 用户名：`Admin`
- 密码：`123456`

### 3. 普通用户（R_USER）
**权限**：只能查看文书列表和详情
- ❌ 上传文书
- ❌ 批量提取
- ❌ 文书比对
- ❌ 文书审查
- ❌ 结构化提取
- ❌ 下载文档
- ✅ 查看详情

**登录账号**：
- 用户名：`User`
- 密码：`123456`

## 实现方式

### 1. 路由权限配置

**文件**：`src/router/modules/documents.ts`

```typescript
export const documentsRoutes: AppRouteRecord = {
  name: 'Documents',
  path: '/documents',
  component: '/index/index',
  meta: {
    title: 'menus.documents.title',
    icon: 'ri:file-text-line',
    roles: ['R_SUPER', 'R_ADMIN', 'R_USER'] // 所有角色都能访问
  },
  children: [
    {
      path: 'list',
      name: 'DocumentList',
      component: '/documents/list',
      meta: {
        title: 'menus.documents.list',
        keepAlive: true,
        roles: ['R_SUPER', 'R_ADMIN', 'R_USER'],
        authList: [
          { title: '上传文书', authMark: 'upload' },
          { title: '批量提取', authMark: 'batch-extract' },
          { title: '文书比对', authMark: 'compare' },
          { title: '文书审查', authMark: 'review' },
          { title: '结构化提取', authMark: 'extract' },
          { title: '下载', authMark: 'download' }
        ]
      }
    }
  ]
}
```

### 2. Mock 数据配置

**文件**：`src/mock/auth.ts`

```typescript
const mockUsers = [
  {
    userName: 'Super',
    password: '123456',
    userInfo: {
      buttons: [
        'user:add', 'user:edit', 'user:delete', 
        'role:add', 'role:edit', 'role:delete',
        'upload', 'batch-extract', 'compare', 'review', 'extract', 'download'
      ],
      roles: ['R_SUPER']
    }
  },
  {
    userName: 'Admin',
    password: '123456',
    userInfo: {
      buttons: [
        'user:add', 'user:edit', 'user:delete', 
        'role:add', 'role:edit',
        'batch-extract', 'compare', 'review', 'extract', 'download'
      ],
      roles: ['R_ADMIN']
    }
  },
  {
    userName: 'User',
    password: '123456',
    userInfo: {
      buttons: ['user:view'],
      roles: ['R_USER']
    }
  }
]
```

### 3. 页面权限控制

**文件**：`src/views/documents/list/index.vue`

#### 导入权限 Hook
```typescript
import { useAuth } from '@/hooks/core/useAuth'

const { hasAuth } = useAuth()
```

#### 顶部操作按钮权限控制
```vue
<el-button v-if="hasAuth('upload')" type="primary" @click="handleUpload">
  上传文书
</el-button>

<el-button v-if="hasAuth('batch-extract')" type="success" @click="handleBatchExtract">
  批量提取
</el-button>

<el-button v-if="hasAuth('compare')" type="warning" @click="handleCompare">
  文书比对
</el-button>

<el-button v-if="hasAuth('review')" type="danger" @click="handleReview">
  文书审查
</el-button>
```

#### 列表操作按钮权限控制
```vue
<el-table-column label="操作" :width="getOperationColumnWidth()" fixed="right">
  <template #default="{ row }">
    <!-- 所有用户都能查看详情 -->
    <el-button link type="primary" size="small" @click="handleViewDetail(row)">
      查看详情
    </el-button>
    
    <!-- 需要 extract 权限 -->
    <el-button v-if="hasAuth('extract')" link type="success" size="small" @click="handleExtract(row)">
      结构化提取
    </el-button>
    
    <!-- 需要 download 权限 -->
    <el-button v-if="hasAuth('download')" link type="warning" size="small" @click="handleDownloadDoc(row)">
      下载
    </el-button>
    
    <!-- 需要 review 权限 -->
    <el-button v-if="hasAuth('review')" link type="danger" size="small" @click="handleSingleReview(row)">
      文书审查
    </el-button>
  </template>
</el-table-column>
```

#### 动态计算操作列宽度
```typescript
const getOperationColumnWidth = () => {
  let buttonCount = 1 // 查看详情始终显示
  if (hasAuth('extract')) buttonCount++
  if (hasAuth('download')) buttonCount++
  if (hasAuth('review')) buttonCount++
  
  return buttonCount * 80 + 20
}
```

## 权限验证流程

### 1. 用户登录
```
用户输入账号密码
    ↓
后端验证
    ↓
返回 token 和用户信息（包含 roles 和 buttons）
    ↓
前端存储用户信息
```

### 2. 路由权限验证
```
用户访问页面
    ↓
检查路由 meta.roles
    ↓
用户角色在 roles 列表中？
    ├─ 是 → 允许访问
    └─ 否 → 跳转到 403 或首页
```

### 3. 按钮权限验证
```
渲染按钮
    ↓
调用 hasAuth(authMark)
    ↓
检查用户 buttons 数组
    ├─ 包含该权限标识 → 显示按钮
    └─ 不包含 → 隐藏按钮
```

## 使用示例

### 场景 1：超级管理员登录
1. 使用 `Super` / `123456` 登录
2. 可以看到所有功能按钮
3. 顶部显示：上传文书、批量提取、文书比对、文书审查
4. 列表操作显示：查看详情、结构化提取、下载、文书审查

### 场景 2：管理员登录
1. 使用 `Admin` / `123456` 登录
2. 看不到"上传文书"按钮
3. 顶部显示：批量提取、文书比对、文书审查
4. 列表操作显示：查看详情、结构化提取、下载、文书审查

### 场景 3：普通用户登录
1. 使用 `User` / `123456` 登录
2. 顶部没有任何操作按钮
3. 列表操作只显示：查看详情
4. 可以查看文书列表和文档预览
5. 无法进行任何修改操作

## 权限标识说明

| 权限标识 | 说明 | 超级管理员 | 管理员 | 普通用户 |
|---------|------|-----------|--------|---------|
| upload | 上传文书 | ✅ | ❌ | ❌ |
| batch-extract | 批量提取 | ✅ | ✅ | ❌ |
| compare | 文书比对 | ✅ | ✅ | ❌ |
| review | 文书审查 | ✅ | ✅ | ❌ |
| extract | 结构化提取 | ✅ | ✅ | ❌ |
| download | 下载文档 | ✅ | ✅ | ❌ |
| - | 查看详情 | ✅ | ✅ | ✅ |

## 扩展权限

### 添加新权限
1. 在路由配置中添加 authList
2. 在 mock 数据中为对应角色添加权限标识
3. 在页面中使用 `hasAuth('权限标识')` 控制显示

### 示例：添加"删除文书"权限
```typescript
// 1. 路由配置
authList: [
  { title: '删除文书', authMark: 'delete' }
]

// 2. Mock 数据
buttons: ['delete'] // 添加到对应角色

// 3. 页面使用
<el-button v-if="hasAuth('delete')" @click="handleDelete">
  删除
</el-button>
```

## 注意事项

1. **前端权限只是 UI 控制**：真正的权限验证必须在后端进行
2. **权限标识统一**：路由配置、Mock 数据、页面使用的权限标识必须一致
3. **角色继承**：可以考虑实现角色继承，如管理员继承普通用户的权限
4. **动态权限**：当前是静态配置，可以改造为从后端动态获取
5. **权限缓存**：用户权限信息会缓存在 store 中，退出登录时需要清除

## 测试建议

### 功能测试
- [ ] 使用超级管理员账号测试所有功能
- [ ] 使用管理员账号验证无法上传文书
- [ ] 使用普通用户账号验证只能查看详情
- [ ] 测试权限切换（退出登录后换账号）

### 边界测试
- [ ] 测试未登录状态访问
- [ ] 测试 token 过期后的处理
- [ ] 测试直接访问 URL 的权限控制
- [ ] 测试按钮权限动态变化

### 安全测试
- [ ] 尝试绕过前端权限控制
- [ ] 验证后端 API 的权限验证
- [ ] 测试权限提升攻击

## 相关文件

- ✅ `src/router/modules/documents.ts` - 路由权限配置
- ✅ `src/mock/auth.ts` - 用户权限数据
- ✅ `src/views/documents/list/index.vue` - 页面权限控制
- 📖 `src/hooks/core/useAuth.ts` - 权限验证 Hook
- 📖 `src/directives/core/auth.ts` - v-auth 指令
- 📖 `src/directives/core/roles.ts` - v-roles 指令

## 后续优化建议

1. **动态权限管理**：从后端获取权限配置，支持动态调整
2. **权限组合**：支持 AND、OR 等逻辑组合
3. **权限继承**：实现角色继承机制
4. **权限日志**：记录权限验证失败的日志
5. **权限提示**：无权限时显示友好提示
6. **批量权限控制**：使用指令批量控制多个元素
